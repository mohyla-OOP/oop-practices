#pragma once
#include <type_traits>
#include <iostream>

// C++98-style aggregate with manual new/delete (for teaching purposes)
class Aggregee {
public:
    Aggregee(int v = 0) : v_(v) {}
    int value() const { return v_; }
private:
    int v_;
};

class Aggregate {
    Aggregee* p_ = nullptr; // raw owning pointer
public:
    Aggregate() = default;

    // Explicit construction of the aggregated object
    explicit Aggregate(const Aggregee& a) : p_(new Aggregee(a)) {}

    // Rule of Three (must be written by hand):
    Aggregate(const Aggregate& other)
        : p_(other.p_ ? new Aggregee(*other.p_) : nullptr) {
    }

    Aggregate& operator=(const Aggregate& other) {
        if (this != &other) {
            delete p_;
            p_ = other.p_ ? new Aggregee(*other.p_) : nullptr;
        }
        return *this;
    }

    ~Aggregate() { delete p_; }  // must not forget!

    bool empty() const { return p_ == nullptr; }
    const Aggregee* get() const { return p_; }
};
Aggregate af()
{
	return Aggregate();
}

Aggregate ag()
{
	Aggregate x;
	return x;
}

Aggregate ah()
{
	return std::move(Aggregate());
}

class MoveOnly {
public:
	MoveOnly() = default;
	MoveOnly(const MoveOnly&) = delete;
	MoveOnly(MoveOnly&&) = default;
	MoveOnly& operator=(const MoveOnly&) = delete;
	MoveOnly& operator=(MoveOnly&&) = default;
	~MoveOnly() = default;
};

MoveOnly fMoveOnly()
{
	return MoveOnly();
}

#include <memory>
class AggregateUnique {
    std::unique_ptr<Aggregee> p_ = nullptr; // exclusive ownership, nullable by design
public:
    AggregateUnique() = default;

    explicit AggregateUnique(const Aggregee& a)
        : p_(std::make_unique<Aggregee>(a)) {
    }

    explicit AggregateUnique(const Aggregee* a)
        : p_(std::make_unique<Aggregee>(*a)) {
    }

    // Rule of Zero: no manual dtor/copy/move needed.
    // Copying semantics can be defined explicitly if you want deep copy:
    AggregateUnique(const AggregateUnique& other)
        : p_(other.p_ ? std::make_unique<Aggregee>(*other.p_) : nullptr) {
    }

    AggregateUnique& operator=(const AggregateUnique& other) {
        if (this != &other) {
            p_ = other.p_ ? std::make_unique<Aggregee>(*other.p_) : nullptr;
        }
        return *this;
    }

    // Move operations are generated by default and are correct.
    bool empty() const { return !p_; }
    const Aggregee* get() const { return p_.get(); }
};


